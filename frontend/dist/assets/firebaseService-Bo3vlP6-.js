import{am as f,an as m,ao as O,ap as p,aq as w,ar as g,as as h,at as S,au as y,av as b,aw as _}from"./index-CQi3PHFX.js";class I{constructor(){this.app=null,this.db=null,this.connected=!1,this.useLocalStorage=!1,this.dbName="SecureDigitalWallet"}async connect(){if(this.connected&&this.db)return this.db;try{const e={apiKey:"AIzaSyBYQwkLnzoN7ECF1X0x7F-VWsSqqPwDbPc",authDomain:"digital-b6a84.firebaseapp.com",projectId:"digital-b6a84",storageBucket:"digital-b6a84.firebasestorage.app",messagingSenderId:"687546109945",appId:"1:687546109945:web:d5ec1d0850792343777728"};return!e.apiKey||!e.projectId?(console.warn("⚠️ Firebase not configured. Using localStorage fallback."),console.log("To use Firebase Firestore:"),console.log("1. Create a Firebase project at https://console.firebase.google.com"),console.log("2. Enable Firestore Database"),console.log("3. Add Firebase config to frontend/.env"),this.useLocalStorage=!0,this.connected=!0,console.log("✅ Firebase service initialized (localStorage mode)"),!0):(console.log("🔥 Connecting to Firebase Firestore..."),this.app=f(e),this.db=m(this.app),this.connected=!0,this.useLocalStorage=!1,console.log("✅ Connected to Firebase Firestore:",e.projectId),this.db)}catch(e){return console.error("❌ Firebase connection error:",e),console.log("⚠️ Falling back to localStorage mode"),this.useLocalStorage=!0,this.connected=!0,!0}}async getDB(){return this.connected||await this.connect(),this}async _executeOperation(e,r,t={},n=null){return await this.getDB(),!this.useLocalStorage&&this.db?await this._executeFirestoreOperation(e,r,t,n):await this._executeLocalStorageOperation(e,r,t,n)}async _executeFirestoreOperation(e,r,t={},n=null){try{const c=O(this.db,e);switch(r){case"find":{if(Object.keys(t).length===0)return(await g(c)).docs.map(o=>({_id:o.id,...o.data()}));{const s=Object.keys(t)[0],o=t[s],i=p(c,w(s,"==",o));return(await g(i)).docs.map(d=>({_id:d.id,...d.data()}))}}case"findOne":if(t._id){const s=h(this.db,e,t._id),o=await _(s);return o.exists()?{_id:o.id,...o.data()}:null}else{const s=Object.keys(t)[0],o=t[s],i=p(c,w(s,"==",o)),a=await g(i);if(a.empty)return null;const d=a.docs[0];return{_id:d.id,...d.data()}}case"insertOne":{const s=n._id||`${Date.now()}_${Math.random().toString(36).substr(2,9)}`,o=h(this.db,e,s),{_id:i,...a}=n;return await b(o,a),{insertedId:s}}case"updateOne":{let s=t._id;if(!s){const o=Object.keys(t)[0],i=t[o],a=p(c,w(o,"==",i)),d=await g(a);d.empty||(s=d.docs[0].id)}if(s){const o=h(this.db,e,s),i=n.$set||n;return await y(o,i),{matchedCount:1,modifiedCount:1,upsertedCount:0}}else{const o=`${Date.now()}_${Math.random().toString(36).substr(2,9)}`,i=h(this.db,e,o),a={...t,...n.$set||n};return await b(i,a),{matchedCount:0,modifiedCount:0,upsertedCount:1}}}case"deleteOne":{let s=t._id;if(!s){const o=Object.keys(t)[0],i=t[o],a=p(c,w(o,"==",i)),d=await g(a);d.empty||(s=d.docs[0].id)}if(s){const o=h(this.db,e,s);return await S(o),{deletedCount:1}}else return{deletedCount:0}}default:throw new Error(`Unsupported operation: ${r}`)}}catch(c){throw console.error(`Firestore operation error (${r} on ${e}):`,c),c}}async _executeLocalStorageOperation(e,r,t={},n=null){const c=`firebase_${this.dbName}_${e}`;let s=[];try{const i=localStorage.getItem(c);i&&(s=JSON.parse(i))}catch(i){console.error("Error reading from storage:",i)}let o=null;switch(r){case"find":o=s.filter(l=>!t||Object.keys(t).length===0?!0:Object.keys(t).every(u=>l[u]===t[u]));break;case"findOne":o=s.find(l=>!t||Object.keys(t).length===0?!0:Object.keys(t).every(u=>l[u]===t[u]));break;case"insertOne":const i={...n,_id:n._id||`${Date.now()}_${Math.random().toString(36).substr(2,9)}`};s.push(i),localStorage.setItem(c,JSON.stringify(s)),o={insertedId:i._id};break;case"updateOne":const a=s.findIndex(l=>Object.keys(t).every(u=>l[u]===t[u]));if(a>=0)s[a]={...s[a],...n.$set||n},localStorage.setItem(c,JSON.stringify(s)),o={matchedCount:1,modifiedCount:1,upsertedCount:0};else{const l={...t,...n.$set||n,_id:`${Date.now()}_${Math.random().toString(36).substr(2,9)}`};s.push(l),localStorage.setItem(c,JSON.stringify(s)),o={matchedCount:0,modifiedCount:0,upsertedCount:1}}break;case"deleteOne":const d=s.findIndex(l=>Object.keys(t).every(u=>l[u]===t[u]));d>=0?(s.splice(d,1),localStorage.setItem(c,JSON.stringify(s)),o={deletedCount:1}):o={deletedCount:0};break;default:throw new Error(`Unsupported operation: ${r}`)}return o}async disconnect(){this.connected=!1,console.log("Disconnected from Firebase")}async storeDocument(e,r){try{await this.getDB();const t={username:e,...r,uploadedAt:new Date().toISOString(),updatedAt:new Date().toISOString()},n=await this._executeOperation("documents","findOne",{username:e});if(n)return await this._executeOperation("documents","updateOne",{username:e},{$set:{...t,createdAt:n.createdAt||n.uploadedAt}}),console.log("Document updated for user:",e),n._id;{const c=await this._executeOperation("documents","insertOne",{},{...t,createdAt:new Date().toISOString()});return console.log("Document stored for user:",e,"with ID:",c.insertedId),c.insertedId}}catch(t){throw console.error("Error storing document:",t),t}}async getDocumentByUsername(e){try{return await this.getDB(),await this._executeOperation("documents","findOne",{username:e})}catch(r){return console.error("Error retrieving document:",r),null}}async getAllDocumentsByUsername(e){try{return await this.getDB(),await this._executeOperation("documents","find",{username:e})}catch(r){return console.error("Error retrieving documents:",r),[]}}async hasDocument(e){return!!await this.getDocumentByUsername(e)}async updateDocument(e,r){try{await this.getDB();const t=await this._executeOperation("documents","updateOne",{username:e},{$set:{...r,updatedAt:new Date().toISOString()}});if(t.matchedCount===0&&t.upsertedCount===0)throw new Error("Document not found");return console.log("Document updated for user:",e),t}catch(t){throw console.error("Error updating document:",t),t}}async addSubmission(e){try{await this.getDB();const r={...e,id:e.id||Date.now(),submittedAt:e.submittedAt||new Date().toISOString()},t=await this._executeOperation("submissions","insertOne",{},r);return console.log("Submission added with ID:",t.insertedId),t.insertedId}catch(r){throw console.error("Error adding submission:",r),r}}async updateSubmission(e,r){try{await this.getDB();const t=await this._executeOperation("submissions","updateOne",{id:e},{$set:r});return console.log("Submission updated:",e),t}catch(t){throw console.error("Error updating submission:",t),t}}async getAllSubmissions(){try{return await this.getDB(),await this._executeOperation("submissions","find",{})}catch(e){return console.error("Error retrieving submissions:",e),[]}}async deleteSubmission(e){try{await this.getDB();const r=await this._executeOperation("submissions","deleteOne",{id:e});return console.log("Submission deleted:",e),r.deletedCount>0}catch(r){throw console.error("Error deleting submission:",r),r}}async clearAllSubmissions(){try{await this.getDB();const e=await this.getAllSubmissions();for(const r of e)await this.deleteSubmission(r.id);return console.log("All submissions cleared"),!0}catch(e){throw console.error("Error clearing submissions:",e),e}}async getSetting(e){try{await this.getDB();const r=await this._executeOperation("settings","findOne",{key:e});return r?r.value:null}catch(r){return console.error("Error retrieving setting:",r),null}}async setSetting(e,r){try{await this.getDB();const t=await this._executeOperation("settings","updateOne",{key:e},{$set:{key:e,value:r,updatedAt:new Date().toISOString()}});return console.log("Setting updated:",e),t}catch(t){throw console.error("Error setting value:",t),t}}async getAllSettings(){try{await this.getDB();const e=await this._executeOperation("settings","find",{}),r={};return e.forEach(t=>{r[t.key]=t.value}),r}catch(e){return console.error("Error retrieving settings:",e),{}}}async saveUser(e,r){try{await this.getDB();const t=await this._executeOperation("users","updateOne",{username:e},{$set:{username:e,...r,updatedAt:new Date().toISOString()}});return console.log("User saved:",e),t}catch(t){throw console.error("Error saving user:",t),t}}async createUser(e){try{await this.getDB();const r={...e,createdAt:e.createdAt||new Date().toISOString(),updatedAt:new Date().toISOString()},t=await this._executeOperation("users","insertOne",{},r);return console.log("User created:",e.username),t.insertedId}catch(r){throw console.error("Error creating user:",r),r}}async getUser(e){try{return await this.getDB(),await this._executeOperation("users","findOne",{username:e})}catch(r){return console.error("Error retrieving user:",r),null}}async getAllUsers(){try{return await this.getDB(),await this._executeOperation("users","find",{})}catch(e){return console.error("Error retrieving users:",e),[]}}}const A=new I;export{A as f};
